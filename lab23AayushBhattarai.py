# from Crypto.Cipher import AES
# from Crypto.Random import get_random_bytes
# from Crypto.Util.Padding import pad, unpad
# import secrets

# # Utility function for AES encryption/decryption
# def aes_encrypt(key, plaintext):
#     cipher = AES.new(key, AES.MODE_CBC)
#     ct_bytes = cipher.encrypt(pad(plaintext.encode(), AES.block_size))
#     return cipher.iv + ct_bytes  # prepend IV for decryption

# def aes_decrypt(key, ciphertext):
#     iv = ciphertext[:AES.block_size]
#     ct = ciphertext[AES.block_size:]
#     cipher = AES.new(key, AES.MODE_CBC, iv)
#     pt = unpad(cipher.decrypt(ct), AES.block_size)
#     return pt.decode()

# # -------------------------------
# # Needham-Schroeder Symmetric Protocol
# # -------------------------------
# def needham_schroeder_sim():
#     print("--- Needham-Schroeder Symmetric Key Protocol Simulation ---\n")

#     # Long-term keys (shared with server)
#     K_A = get_random_bytes(16)  # Alice <-> Server
#     K_B = get_random_bytes(16)  # Bob <-> Server

#     # Step 1: Alice generates nonce and requests session key
#     Na = secrets.token_hex(4)
#     print(f"Step 1: A -> S: Request session with B, Nonce={Na}")

#     # Step 2: Server generates session key Ks
#     Ks = get_random_bytes(16)  # AES 128-bit session key
#     # Server encrypts Ks + Na for Alice
#     msg_for_A = aes_encrypt(K_A, Ks.hex() + "," + Na)
#     # Server creates ticket for Bob: Ks encrypted with Bob's key
#     ticket_for_B = aes_encrypt(K_B, Ks.hex() + ",Alice")
#     print("Step 2: S -> A: Sending encrypted session key and ticket for B")

#     # Step 3: Alice forwards ticket to Bob
#     print("Step 3: A -> B: Sending ticket for B")
#     # Bob decrypts ticket
#     ticket_decrypted = aes_decrypt(K_B, ticket_for_B)
#     Ks_from_ticket, sender = ticket_decrypted.split(",")
#     Ks_from_ticket = bytes.fromhex(Ks_from_ticket)
#     print(f"         Bob received session key Ks from ticket: {Ks_from_ticket.hex()} from {sender}")

#     # Step 4: Bob sends nonce challenge to Alice
#     Nb = secrets.token_hex(4)
#     print(f"Step 4: B -> A: Challenge with Nonce={Nb}")
#     # Alice encrypts Nb with Ks and sends back
#     encrypted_Nb = aes_encrypt(Ks_from_ticket, Nb)
#     print(f"Step 5: A -> B: Responding with encrypted Nb")

#     # Step 5: Bob decrypts response
#     decrypted_Nb = aes_decrypt(Ks_from_ticket, encrypted_Nb)
#     print(f"         Bob decrypted Nb: {decrypted_Nb}")

#     # Integrity check
#     if decrypted_Nb == Nb:
#         print("\nAuthentication SUCCESS! Alice and Bob share the session key securely.")
#     else:
#         print("\nAuthentication FAILED!")

# # Run simulation
# needham_schroeder_sim()
# Lab 23: Needham-Schroeder Protocol Simulation
import secrets

def simulate_ns():
    print("--- Needham-Schroeder Simulation ---")
    
    # Alice (A), Bob (B), Server (S)
    Na = secrets.token_hex(4) # Nonce A
    print(f"Step 1: A -> S: Request session with B, Nonce={Na}")
    
    Ks = "aayushiscoook" # Session Key generated by Server
    print(f"Step 2: S -> A: Sending Session Key and Ticket for B")
    
    print(f"Step 3: A -> B: Sending Ticket (Contains Ks)")
    
    Nb = secrets.token_hex(4) # Nonce B
    print(f"Step 4: B -> A: Challenge with Nonce={Nb}")
    
    response = hex(int(Nb, 16) - 1)
    print(f"Step 5: A -> B: Correct response {response}. Auth Complete.")

simulate_ns()